// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/bborbe/kv"
)

type RelationStoreString struct {
	AddStub        func(context.Context, string, []string) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	addReturns struct {
		result1 error
	}
	addReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(context.Context, string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	IDsStub        func(context.Context, string) ([]string, error)
	iDsMutex       sync.RWMutex
	iDsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	iDsReturns struct {
		result1 []string
		result2 error
	}
	iDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	InvertStub        func() kv.RelationStore[string, string]
	invertMutex       sync.RWMutex
	invertArgsForCall []struct {
	}
	invertReturns struct {
		result1 kv.RelationStore[string, string]
	}
	invertReturnsOnCall map[int]struct {
		result1 kv.RelationStore[string, string]
	}
	MapIDRelationsStub        func(context.Context, func(ctx context.Context, key string, relatedIDs []string) error) error
	mapIDRelationsMutex       sync.RWMutex
	mapIDRelationsArgsForCall []struct {
		arg1 context.Context
		arg2 func(ctx context.Context, key string, relatedIDs []string) error
	}
	mapIDRelationsReturns struct {
		result1 error
	}
	mapIDRelationsReturnsOnCall map[int]struct {
		result1 error
	}
	MapRelationIDsStub        func(context.Context, func(ctx context.Context, key string, ids []string) error) error
	mapRelationIDsMutex       sync.RWMutex
	mapRelationIDsArgsForCall []struct {
		arg1 context.Context
		arg2 func(ctx context.Context, key string, ids []string) error
	}
	mapRelationIDsReturns struct {
		result1 error
	}
	mapRelationIDsReturnsOnCall map[int]struct {
		result1 error
	}
	RelatedIDsStub        func(context.Context, string) ([]string, error)
	relatedIDsMutex       sync.RWMutex
	relatedIDsArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	relatedIDsReturns struct {
		result1 []string
		result2 error
	}
	relatedIDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	RemoveStub        func(context.Context, string, []string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	ReplaceStub        func(context.Context, string, []string) error
	replaceMutex       sync.RWMutex
	replaceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}
	replaceReturns struct {
		result1 error
	}
	replaceReturnsOnCall map[int]struct {
		result1 error
	}
	StreamIDsStub        func(context.Context, chan<- string) error
	streamIDsMutex       sync.RWMutex
	streamIDsArgsForCall []struct {
		arg1 context.Context
		arg2 chan<- string
	}
	streamIDsReturns struct {
		result1 error
	}
	streamIDsReturnsOnCall map[int]struct {
		result1 error
	}
	StreamRelatedIDsStub        func(context.Context, chan<- string) error
	streamRelatedIDsMutex       sync.RWMutex
	streamRelatedIDsArgsForCall []struct {
		arg1 context.Context
		arg2 chan<- string
	}
	streamRelatedIDsReturns struct {
		result1 error
	}
	streamRelatedIDsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *RelationStoreString) Add(arg1 context.Context, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.AddStub
	fakeReturns := fake.addReturns
	fake.recordInvocation("Add", []interface{}{arg1, arg2, arg3Copy})
	fake.addMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *RelationStoreString) AddCalls(stub func(context.Context, string, []string) error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *RelationStoreString) AddArgsForCall(i int) (context.Context, string, []string) {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreString) AddReturns(result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) AddReturnsOnCall(i int, result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) Delete(arg1 context.Context, arg2 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *RelationStoreString) DeleteCalls(stub func(context.Context, string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *RelationStoreString) DeleteArgsForCall(i int) (context.Context, string) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) IDs(arg1 context.Context, arg2 string) ([]string, error) {
	fake.iDsMutex.Lock()
	ret, specificReturn := fake.iDsReturnsOnCall[len(fake.iDsArgsForCall)]
	fake.iDsArgsForCall = append(fake.iDsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.IDsStub
	fakeReturns := fake.iDsReturns
	fake.recordInvocation("IDs", []interface{}{arg1, arg2})
	fake.iDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *RelationStoreString) IDsCallCount() int {
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	return len(fake.iDsArgsForCall)
}

func (fake *RelationStoreString) IDsCalls(stub func(context.Context, string) ([]string, error)) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = stub
}

func (fake *RelationStoreString) IDsArgsForCall(i int) (context.Context, string) {
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	argsForCall := fake.iDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) IDsReturns(result1 []string, result2 error) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = nil
	fake.iDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreString) IDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = nil
	if fake.iDsReturnsOnCall == nil {
		fake.iDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.iDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreString) Invert() kv.RelationStore[string, string] {
	fake.invertMutex.Lock()
	ret, specificReturn := fake.invertReturnsOnCall[len(fake.invertArgsForCall)]
	fake.invertArgsForCall = append(fake.invertArgsForCall, struct {
	}{})
	stub := fake.InvertStub
	fakeReturns := fake.invertReturns
	fake.recordInvocation("Invert", []interface{}{})
	fake.invertMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) InvertCallCount() int {
	fake.invertMutex.RLock()
	defer fake.invertMutex.RUnlock()
	return len(fake.invertArgsForCall)
}

func (fake *RelationStoreString) InvertCalls(stub func() kv.RelationStore[string, string]) {
	fake.invertMutex.Lock()
	defer fake.invertMutex.Unlock()
	fake.InvertStub = stub
}

func (fake *RelationStoreString) InvertReturns(result1 kv.RelationStore[string, string]) {
	fake.invertMutex.Lock()
	defer fake.invertMutex.Unlock()
	fake.InvertStub = nil
	fake.invertReturns = struct {
		result1 kv.RelationStore[string, string]
	}{result1}
}

func (fake *RelationStoreString) InvertReturnsOnCall(i int, result1 kv.RelationStore[string, string]) {
	fake.invertMutex.Lock()
	defer fake.invertMutex.Unlock()
	fake.InvertStub = nil
	if fake.invertReturnsOnCall == nil {
		fake.invertReturnsOnCall = make(map[int]struct {
			result1 kv.RelationStore[string, string]
		})
	}
	fake.invertReturnsOnCall[i] = struct {
		result1 kv.RelationStore[string, string]
	}{result1}
}

func (fake *RelationStoreString) MapIDRelations(arg1 context.Context, arg2 func(ctx context.Context, key string, relatedIDs []string) error) error {
	fake.mapIDRelationsMutex.Lock()
	ret, specificReturn := fake.mapIDRelationsReturnsOnCall[len(fake.mapIDRelationsArgsForCall)]
	fake.mapIDRelationsArgsForCall = append(fake.mapIDRelationsArgsForCall, struct {
		arg1 context.Context
		arg2 func(ctx context.Context, key string, relatedIDs []string) error
	}{arg1, arg2})
	stub := fake.MapIDRelationsStub
	fakeReturns := fake.mapIDRelationsReturns
	fake.recordInvocation("MapIDRelations", []interface{}{arg1, arg2})
	fake.mapIDRelationsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) MapIDRelationsCallCount() int {
	fake.mapIDRelationsMutex.RLock()
	defer fake.mapIDRelationsMutex.RUnlock()
	return len(fake.mapIDRelationsArgsForCall)
}

func (fake *RelationStoreString) MapIDRelationsCalls(stub func(context.Context, func(ctx context.Context, key string, relatedIDs []string) error) error) {
	fake.mapIDRelationsMutex.Lock()
	defer fake.mapIDRelationsMutex.Unlock()
	fake.MapIDRelationsStub = stub
}

func (fake *RelationStoreString) MapIDRelationsArgsForCall(i int) (context.Context, func(ctx context.Context, key string, relatedIDs []string) error) {
	fake.mapIDRelationsMutex.RLock()
	defer fake.mapIDRelationsMutex.RUnlock()
	argsForCall := fake.mapIDRelationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) MapIDRelationsReturns(result1 error) {
	fake.mapIDRelationsMutex.Lock()
	defer fake.mapIDRelationsMutex.Unlock()
	fake.MapIDRelationsStub = nil
	fake.mapIDRelationsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) MapIDRelationsReturnsOnCall(i int, result1 error) {
	fake.mapIDRelationsMutex.Lock()
	defer fake.mapIDRelationsMutex.Unlock()
	fake.MapIDRelationsStub = nil
	if fake.mapIDRelationsReturnsOnCall == nil {
		fake.mapIDRelationsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mapIDRelationsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) MapRelationIDs(arg1 context.Context, arg2 func(ctx context.Context, key string, ids []string) error) error {
	fake.mapRelationIDsMutex.Lock()
	ret, specificReturn := fake.mapRelationIDsReturnsOnCall[len(fake.mapRelationIDsArgsForCall)]
	fake.mapRelationIDsArgsForCall = append(fake.mapRelationIDsArgsForCall, struct {
		arg1 context.Context
		arg2 func(ctx context.Context, key string, ids []string) error
	}{arg1, arg2})
	stub := fake.MapRelationIDsStub
	fakeReturns := fake.mapRelationIDsReturns
	fake.recordInvocation("MapRelationIDs", []interface{}{arg1, arg2})
	fake.mapRelationIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) MapRelationIDsCallCount() int {
	fake.mapRelationIDsMutex.RLock()
	defer fake.mapRelationIDsMutex.RUnlock()
	return len(fake.mapRelationIDsArgsForCall)
}

func (fake *RelationStoreString) MapRelationIDsCalls(stub func(context.Context, func(ctx context.Context, key string, ids []string) error) error) {
	fake.mapRelationIDsMutex.Lock()
	defer fake.mapRelationIDsMutex.Unlock()
	fake.MapRelationIDsStub = stub
}

func (fake *RelationStoreString) MapRelationIDsArgsForCall(i int) (context.Context, func(ctx context.Context, key string, ids []string) error) {
	fake.mapRelationIDsMutex.RLock()
	defer fake.mapRelationIDsMutex.RUnlock()
	argsForCall := fake.mapRelationIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) MapRelationIDsReturns(result1 error) {
	fake.mapRelationIDsMutex.Lock()
	defer fake.mapRelationIDsMutex.Unlock()
	fake.MapRelationIDsStub = nil
	fake.mapRelationIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) MapRelationIDsReturnsOnCall(i int, result1 error) {
	fake.mapRelationIDsMutex.Lock()
	defer fake.mapRelationIDsMutex.Unlock()
	fake.MapRelationIDsStub = nil
	if fake.mapRelationIDsReturnsOnCall == nil {
		fake.mapRelationIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mapRelationIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) RelatedIDs(arg1 context.Context, arg2 string) ([]string, error) {
	fake.relatedIDsMutex.Lock()
	ret, specificReturn := fake.relatedIDsReturnsOnCall[len(fake.relatedIDsArgsForCall)]
	fake.relatedIDsArgsForCall = append(fake.relatedIDsArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.RelatedIDsStub
	fakeReturns := fake.relatedIDsReturns
	fake.recordInvocation("RelatedIDs", []interface{}{arg1, arg2})
	fake.relatedIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *RelationStoreString) RelatedIDsCallCount() int {
	fake.relatedIDsMutex.RLock()
	defer fake.relatedIDsMutex.RUnlock()
	return len(fake.relatedIDsArgsForCall)
}

func (fake *RelationStoreString) RelatedIDsCalls(stub func(context.Context, string) ([]string, error)) {
	fake.relatedIDsMutex.Lock()
	defer fake.relatedIDsMutex.Unlock()
	fake.RelatedIDsStub = stub
}

func (fake *RelationStoreString) RelatedIDsArgsForCall(i int) (context.Context, string) {
	fake.relatedIDsMutex.RLock()
	defer fake.relatedIDsMutex.RUnlock()
	argsForCall := fake.relatedIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) RelatedIDsReturns(result1 []string, result2 error) {
	fake.relatedIDsMutex.Lock()
	defer fake.relatedIDsMutex.Unlock()
	fake.RelatedIDsStub = nil
	fake.relatedIDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreString) RelatedIDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.relatedIDsMutex.Lock()
	defer fake.relatedIDsMutex.Unlock()
	fake.RelatedIDsStub = nil
	if fake.relatedIDsReturnsOnCall == nil {
		fake.relatedIDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.relatedIDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreString) Remove(arg1 context.Context, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1, arg2, arg3Copy})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *RelationStoreString) RemoveCalls(stub func(context.Context, string, []string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *RelationStoreString) RemoveArgsForCall(i int) (context.Context, string, []string) {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreString) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) Replace(arg1 context.Context, arg2 string, arg3 []string) error {
	var arg3Copy []string
	if arg3 != nil {
		arg3Copy = make([]string, len(arg3))
		copy(arg3Copy, arg3)
	}
	fake.replaceMutex.Lock()
	ret, specificReturn := fake.replaceReturnsOnCall[len(fake.replaceArgsForCall)]
	fake.replaceArgsForCall = append(fake.replaceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 []string
	}{arg1, arg2, arg3Copy})
	stub := fake.ReplaceStub
	fakeReturns := fake.replaceReturns
	fake.recordInvocation("Replace", []interface{}{arg1, arg2, arg3Copy})
	fake.replaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) ReplaceCallCount() int {
	fake.replaceMutex.RLock()
	defer fake.replaceMutex.RUnlock()
	return len(fake.replaceArgsForCall)
}

func (fake *RelationStoreString) ReplaceCalls(stub func(context.Context, string, []string) error) {
	fake.replaceMutex.Lock()
	defer fake.replaceMutex.Unlock()
	fake.ReplaceStub = stub
}

func (fake *RelationStoreString) ReplaceArgsForCall(i int) (context.Context, string, []string) {
	fake.replaceMutex.RLock()
	defer fake.replaceMutex.RUnlock()
	argsForCall := fake.replaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreString) ReplaceReturns(result1 error) {
	fake.replaceMutex.Lock()
	defer fake.replaceMutex.Unlock()
	fake.ReplaceStub = nil
	fake.replaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) ReplaceReturnsOnCall(i int, result1 error) {
	fake.replaceMutex.Lock()
	defer fake.replaceMutex.Unlock()
	fake.ReplaceStub = nil
	if fake.replaceReturnsOnCall == nil {
		fake.replaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.replaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) StreamIDs(arg1 context.Context, arg2 chan<- string) error {
	fake.streamIDsMutex.Lock()
	ret, specificReturn := fake.streamIDsReturnsOnCall[len(fake.streamIDsArgsForCall)]
	fake.streamIDsArgsForCall = append(fake.streamIDsArgsForCall, struct {
		arg1 context.Context
		arg2 chan<- string
	}{arg1, arg2})
	stub := fake.StreamIDsStub
	fakeReturns := fake.streamIDsReturns
	fake.recordInvocation("StreamIDs", []interface{}{arg1, arg2})
	fake.streamIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) StreamIDsCallCount() int {
	fake.streamIDsMutex.RLock()
	defer fake.streamIDsMutex.RUnlock()
	return len(fake.streamIDsArgsForCall)
}

func (fake *RelationStoreString) StreamIDsCalls(stub func(context.Context, chan<- string) error) {
	fake.streamIDsMutex.Lock()
	defer fake.streamIDsMutex.Unlock()
	fake.StreamIDsStub = stub
}

func (fake *RelationStoreString) StreamIDsArgsForCall(i int) (context.Context, chan<- string) {
	fake.streamIDsMutex.RLock()
	defer fake.streamIDsMutex.RUnlock()
	argsForCall := fake.streamIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) StreamIDsReturns(result1 error) {
	fake.streamIDsMutex.Lock()
	defer fake.streamIDsMutex.Unlock()
	fake.StreamIDsStub = nil
	fake.streamIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) StreamIDsReturnsOnCall(i int, result1 error) {
	fake.streamIDsMutex.Lock()
	defer fake.streamIDsMutex.Unlock()
	fake.StreamIDsStub = nil
	if fake.streamIDsReturnsOnCall == nil {
		fake.streamIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) StreamRelatedIDs(arg1 context.Context, arg2 chan<- string) error {
	fake.streamRelatedIDsMutex.Lock()
	ret, specificReturn := fake.streamRelatedIDsReturnsOnCall[len(fake.streamRelatedIDsArgsForCall)]
	fake.streamRelatedIDsArgsForCall = append(fake.streamRelatedIDsArgsForCall, struct {
		arg1 context.Context
		arg2 chan<- string
	}{arg1, arg2})
	stub := fake.StreamRelatedIDsStub
	fakeReturns := fake.streamRelatedIDsReturns
	fake.recordInvocation("StreamRelatedIDs", []interface{}{arg1, arg2})
	fake.streamRelatedIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreString) StreamRelatedIDsCallCount() int {
	fake.streamRelatedIDsMutex.RLock()
	defer fake.streamRelatedIDsMutex.RUnlock()
	return len(fake.streamRelatedIDsArgsForCall)
}

func (fake *RelationStoreString) StreamRelatedIDsCalls(stub func(context.Context, chan<- string) error) {
	fake.streamRelatedIDsMutex.Lock()
	defer fake.streamRelatedIDsMutex.Unlock()
	fake.StreamRelatedIDsStub = stub
}

func (fake *RelationStoreString) StreamRelatedIDsArgsForCall(i int) (context.Context, chan<- string) {
	fake.streamRelatedIDsMutex.RLock()
	defer fake.streamRelatedIDsMutex.RUnlock()
	argsForCall := fake.streamRelatedIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *RelationStoreString) StreamRelatedIDsReturns(result1 error) {
	fake.streamRelatedIDsMutex.Lock()
	defer fake.streamRelatedIDsMutex.Unlock()
	fake.StreamRelatedIDsStub = nil
	fake.streamRelatedIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) StreamRelatedIDsReturnsOnCall(i int, result1 error) {
	fake.streamRelatedIDsMutex.Lock()
	defer fake.streamRelatedIDsMutex.Unlock()
	fake.StreamRelatedIDsStub = nil
	if fake.streamRelatedIDsReturnsOnCall == nil {
		fake.streamRelatedIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamRelatedIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreString) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	fake.invertMutex.RLock()
	defer fake.invertMutex.RUnlock()
	fake.mapIDRelationsMutex.RLock()
	defer fake.mapIDRelationsMutex.RUnlock()
	fake.mapRelationIDsMutex.RLock()
	defer fake.mapRelationIDsMutex.RUnlock()
	fake.relatedIDsMutex.RLock()
	defer fake.relatedIDsMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.replaceMutex.RLock()
	defer fake.replaceMutex.RUnlock()
	fake.streamIDsMutex.RLock()
	defer fake.streamIDsMutex.RUnlock()
	fake.streamRelatedIDsMutex.RLock()
	defer fake.streamRelatedIDsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *RelationStoreString) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kv.RelationStoreString = new(RelationStoreString)
