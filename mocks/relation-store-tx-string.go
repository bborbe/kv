// Code generated by counterfeiter. DO NOT EDIT.
package mocks

import (
	"context"
	"sync"

	"github.com/bborbe/kv"
)

type RelationStoreTxString struct {
	AddStub        func(context.Context, kv.Tx, string, []string) error
	addMutex       sync.RWMutex
	addArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
		arg4 []string
	}
	addReturns struct {
		result1 error
	}
	addReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteStub        func(context.Context, kv.Tx, string) error
	deleteMutex       sync.RWMutex
	deleteArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
	}
	deleteReturns struct {
		result1 error
	}
	deleteReturnsOnCall map[int]struct {
		result1 error
	}
	IDsStub        func(context.Context, kv.Tx, string) ([]string, error)
	iDsMutex       sync.RWMutex
	iDsArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
	}
	iDsReturns struct {
		result1 []string
		result2 error
	}
	iDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	InvertStub        func() kv.RelationStoreTx[string, string]
	invertMutex       sync.RWMutex
	invertArgsForCall []struct {
	}
	invertReturns struct {
		result1 kv.RelationStoreTx[string, string]
	}
	invertReturnsOnCall map[int]struct {
		result1 kv.RelationStoreTx[string, string]
	}
	MapIDRelationsStub        func(context.Context, kv.Tx, func(ctx context.Context, key string, relatedIDs []string) error) error
	mapIDRelationsMutex       sync.RWMutex
	mapIDRelationsArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 func(ctx context.Context, key string, relatedIDs []string) error
	}
	mapIDRelationsReturns struct {
		result1 error
	}
	mapIDRelationsReturnsOnCall map[int]struct {
		result1 error
	}
	MapRelationIDsStub        func(context.Context, kv.Tx, func(ctx context.Context, key string, ids []string) error) error
	mapRelationIDsMutex       sync.RWMutex
	mapRelationIDsArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 func(ctx context.Context, key string, ids []string) error
	}
	mapRelationIDsReturns struct {
		result1 error
	}
	mapRelationIDsReturnsOnCall map[int]struct {
		result1 error
	}
	RelatedIDsStub        func(context.Context, kv.Tx, string) ([]string, error)
	relatedIDsMutex       sync.RWMutex
	relatedIDsArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
	}
	relatedIDsReturns struct {
		result1 []string
		result2 error
	}
	relatedIDsReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	RemoveStub        func(context.Context, kv.Tx, string, []string) error
	removeMutex       sync.RWMutex
	removeArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
		arg4 []string
	}
	removeReturns struct {
		result1 error
	}
	removeReturnsOnCall map[int]struct {
		result1 error
	}
	ReplaceStub        func(context.Context, kv.Tx, string, []string) error
	replaceMutex       sync.RWMutex
	replaceArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
		arg4 []string
	}
	replaceReturns struct {
		result1 error
	}
	replaceReturnsOnCall map[int]struct {
		result1 error
	}
	StreamIDsStub        func(context.Context, kv.Tx, chan<- string) error
	streamIDsMutex       sync.RWMutex
	streamIDsArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 chan<- string
	}
	streamIDsReturns struct {
		result1 error
	}
	streamIDsReturnsOnCall map[int]struct {
		result1 error
	}
	StreamRelatedIDsStub        func(context.Context, kv.Tx, chan<- string) error
	streamRelatedIDsMutex       sync.RWMutex
	streamRelatedIDsArgsForCall []struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 chan<- string
	}
	streamRelatedIDsReturns struct {
		result1 error
	}
	streamRelatedIDsReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *RelationStoreTxString) Add(arg1 context.Context, arg2 kv.Tx, arg3 string, arg4 []string) error {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.addMutex.Lock()
	ret, specificReturn := fake.addReturnsOnCall[len(fake.addArgsForCall)]
	fake.addArgsForCall = append(fake.addArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.AddStub
	fakeReturns := fake.addReturns
	fake.recordInvocation("Add", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.addMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) AddCallCount() int {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	return len(fake.addArgsForCall)
}

func (fake *RelationStoreTxString) AddCalls(stub func(context.Context, kv.Tx, string, []string) error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = stub
}

func (fake *RelationStoreTxString) AddArgsForCall(i int) (context.Context, kv.Tx, string, []string) {
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	argsForCall := fake.addArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *RelationStoreTxString) AddReturns(result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	fake.addReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) AddReturnsOnCall(i int, result1 error) {
	fake.addMutex.Lock()
	defer fake.addMutex.Unlock()
	fake.AddStub = nil
	if fake.addReturnsOnCall == nil {
		fake.addReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) Delete(arg1 context.Context, arg2 kv.Tx, arg3 string) error {
	fake.deleteMutex.Lock()
	ret, specificReturn := fake.deleteReturnsOnCall[len(fake.deleteArgsForCall)]
	fake.deleteArgsForCall = append(fake.deleteArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteStub
	fakeReturns := fake.deleteReturns
	fake.recordInvocation("Delete", []interface{}{arg1, arg2, arg3})
	fake.deleteMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) DeleteCallCount() int {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	return len(fake.deleteArgsForCall)
}

func (fake *RelationStoreTxString) DeleteCalls(stub func(context.Context, kv.Tx, string) error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = stub
}

func (fake *RelationStoreTxString) DeleteArgsForCall(i int) (context.Context, kv.Tx, string) {
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	argsForCall := fake.deleteArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) DeleteReturns(result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	fake.deleteReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) DeleteReturnsOnCall(i int, result1 error) {
	fake.deleteMutex.Lock()
	defer fake.deleteMutex.Unlock()
	fake.DeleteStub = nil
	if fake.deleteReturnsOnCall == nil {
		fake.deleteReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) IDs(arg1 context.Context, arg2 kv.Tx, arg3 string) ([]string, error) {
	fake.iDsMutex.Lock()
	ret, specificReturn := fake.iDsReturnsOnCall[len(fake.iDsArgsForCall)]
	fake.iDsArgsForCall = append(fake.iDsArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.IDsStub
	fakeReturns := fake.iDsReturns
	fake.recordInvocation("IDs", []interface{}{arg1, arg2, arg3})
	fake.iDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *RelationStoreTxString) IDsCallCount() int {
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	return len(fake.iDsArgsForCall)
}

func (fake *RelationStoreTxString) IDsCalls(stub func(context.Context, kv.Tx, string) ([]string, error)) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = stub
}

func (fake *RelationStoreTxString) IDsArgsForCall(i int) (context.Context, kv.Tx, string) {
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	argsForCall := fake.iDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) IDsReturns(result1 []string, result2 error) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = nil
	fake.iDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreTxString) IDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.iDsMutex.Lock()
	defer fake.iDsMutex.Unlock()
	fake.IDsStub = nil
	if fake.iDsReturnsOnCall == nil {
		fake.iDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.iDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreTxString) Invert() kv.RelationStoreTx[string, string] {
	fake.invertMutex.Lock()
	ret, specificReturn := fake.invertReturnsOnCall[len(fake.invertArgsForCall)]
	fake.invertArgsForCall = append(fake.invertArgsForCall, struct {
	}{})
	stub := fake.InvertStub
	fakeReturns := fake.invertReturns
	fake.recordInvocation("Invert", []interface{}{})
	fake.invertMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) InvertCallCount() int {
	fake.invertMutex.RLock()
	defer fake.invertMutex.RUnlock()
	return len(fake.invertArgsForCall)
}

func (fake *RelationStoreTxString) InvertCalls(stub func() kv.RelationStoreTx[string, string]) {
	fake.invertMutex.Lock()
	defer fake.invertMutex.Unlock()
	fake.InvertStub = stub
}

func (fake *RelationStoreTxString) InvertReturns(result1 kv.RelationStoreTx[string, string]) {
	fake.invertMutex.Lock()
	defer fake.invertMutex.Unlock()
	fake.InvertStub = nil
	fake.invertReturns = struct {
		result1 kv.RelationStoreTx[string, string]
	}{result1}
}

func (fake *RelationStoreTxString) InvertReturnsOnCall(i int, result1 kv.RelationStoreTx[string, string]) {
	fake.invertMutex.Lock()
	defer fake.invertMutex.Unlock()
	fake.InvertStub = nil
	if fake.invertReturnsOnCall == nil {
		fake.invertReturnsOnCall = make(map[int]struct {
			result1 kv.RelationStoreTx[string, string]
		})
	}
	fake.invertReturnsOnCall[i] = struct {
		result1 kv.RelationStoreTx[string, string]
	}{result1}
}

func (fake *RelationStoreTxString) MapIDRelations(arg1 context.Context, arg2 kv.Tx, arg3 func(ctx context.Context, key string, relatedIDs []string) error) error {
	fake.mapIDRelationsMutex.Lock()
	ret, specificReturn := fake.mapIDRelationsReturnsOnCall[len(fake.mapIDRelationsArgsForCall)]
	fake.mapIDRelationsArgsForCall = append(fake.mapIDRelationsArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 func(ctx context.Context, key string, relatedIDs []string) error
	}{arg1, arg2, arg3})
	stub := fake.MapIDRelationsStub
	fakeReturns := fake.mapIDRelationsReturns
	fake.recordInvocation("MapIDRelations", []interface{}{arg1, arg2, arg3})
	fake.mapIDRelationsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) MapIDRelationsCallCount() int {
	fake.mapIDRelationsMutex.RLock()
	defer fake.mapIDRelationsMutex.RUnlock()
	return len(fake.mapIDRelationsArgsForCall)
}

func (fake *RelationStoreTxString) MapIDRelationsCalls(stub func(context.Context, kv.Tx, func(ctx context.Context, key string, relatedIDs []string) error) error) {
	fake.mapIDRelationsMutex.Lock()
	defer fake.mapIDRelationsMutex.Unlock()
	fake.MapIDRelationsStub = stub
}

func (fake *RelationStoreTxString) MapIDRelationsArgsForCall(i int) (context.Context, kv.Tx, func(ctx context.Context, key string, relatedIDs []string) error) {
	fake.mapIDRelationsMutex.RLock()
	defer fake.mapIDRelationsMutex.RUnlock()
	argsForCall := fake.mapIDRelationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) MapIDRelationsReturns(result1 error) {
	fake.mapIDRelationsMutex.Lock()
	defer fake.mapIDRelationsMutex.Unlock()
	fake.MapIDRelationsStub = nil
	fake.mapIDRelationsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) MapIDRelationsReturnsOnCall(i int, result1 error) {
	fake.mapIDRelationsMutex.Lock()
	defer fake.mapIDRelationsMutex.Unlock()
	fake.MapIDRelationsStub = nil
	if fake.mapIDRelationsReturnsOnCall == nil {
		fake.mapIDRelationsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mapIDRelationsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) MapRelationIDs(arg1 context.Context, arg2 kv.Tx, arg3 func(ctx context.Context, key string, ids []string) error) error {
	fake.mapRelationIDsMutex.Lock()
	ret, specificReturn := fake.mapRelationIDsReturnsOnCall[len(fake.mapRelationIDsArgsForCall)]
	fake.mapRelationIDsArgsForCall = append(fake.mapRelationIDsArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 func(ctx context.Context, key string, ids []string) error
	}{arg1, arg2, arg3})
	stub := fake.MapRelationIDsStub
	fakeReturns := fake.mapRelationIDsReturns
	fake.recordInvocation("MapRelationIDs", []interface{}{arg1, arg2, arg3})
	fake.mapRelationIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) MapRelationIDsCallCount() int {
	fake.mapRelationIDsMutex.RLock()
	defer fake.mapRelationIDsMutex.RUnlock()
	return len(fake.mapRelationIDsArgsForCall)
}

func (fake *RelationStoreTxString) MapRelationIDsCalls(stub func(context.Context, kv.Tx, func(ctx context.Context, key string, ids []string) error) error) {
	fake.mapRelationIDsMutex.Lock()
	defer fake.mapRelationIDsMutex.Unlock()
	fake.MapRelationIDsStub = stub
}

func (fake *RelationStoreTxString) MapRelationIDsArgsForCall(i int) (context.Context, kv.Tx, func(ctx context.Context, key string, ids []string) error) {
	fake.mapRelationIDsMutex.RLock()
	defer fake.mapRelationIDsMutex.RUnlock()
	argsForCall := fake.mapRelationIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) MapRelationIDsReturns(result1 error) {
	fake.mapRelationIDsMutex.Lock()
	defer fake.mapRelationIDsMutex.Unlock()
	fake.MapRelationIDsStub = nil
	fake.mapRelationIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) MapRelationIDsReturnsOnCall(i int, result1 error) {
	fake.mapRelationIDsMutex.Lock()
	defer fake.mapRelationIDsMutex.Unlock()
	fake.MapRelationIDsStub = nil
	if fake.mapRelationIDsReturnsOnCall == nil {
		fake.mapRelationIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mapRelationIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) RelatedIDs(arg1 context.Context, arg2 kv.Tx, arg3 string) ([]string, error) {
	fake.relatedIDsMutex.Lock()
	ret, specificReturn := fake.relatedIDsReturnsOnCall[len(fake.relatedIDsArgsForCall)]
	fake.relatedIDsArgsForCall = append(fake.relatedIDsArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.RelatedIDsStub
	fakeReturns := fake.relatedIDsReturns
	fake.recordInvocation("RelatedIDs", []interface{}{arg1, arg2, arg3})
	fake.relatedIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *RelationStoreTxString) RelatedIDsCallCount() int {
	fake.relatedIDsMutex.RLock()
	defer fake.relatedIDsMutex.RUnlock()
	return len(fake.relatedIDsArgsForCall)
}

func (fake *RelationStoreTxString) RelatedIDsCalls(stub func(context.Context, kv.Tx, string) ([]string, error)) {
	fake.relatedIDsMutex.Lock()
	defer fake.relatedIDsMutex.Unlock()
	fake.RelatedIDsStub = stub
}

func (fake *RelationStoreTxString) RelatedIDsArgsForCall(i int) (context.Context, kv.Tx, string) {
	fake.relatedIDsMutex.RLock()
	defer fake.relatedIDsMutex.RUnlock()
	argsForCall := fake.relatedIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) RelatedIDsReturns(result1 []string, result2 error) {
	fake.relatedIDsMutex.Lock()
	defer fake.relatedIDsMutex.Unlock()
	fake.RelatedIDsStub = nil
	fake.relatedIDsReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreTxString) RelatedIDsReturnsOnCall(i int, result1 []string, result2 error) {
	fake.relatedIDsMutex.Lock()
	defer fake.relatedIDsMutex.Unlock()
	fake.RelatedIDsStub = nil
	if fake.relatedIDsReturnsOnCall == nil {
		fake.relatedIDsReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.relatedIDsReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *RelationStoreTxString) Remove(arg1 context.Context, arg2 kv.Tx, arg3 string, arg4 []string) error {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.removeMutex.Lock()
	ret, specificReturn := fake.removeReturnsOnCall[len(fake.removeArgsForCall)]
	fake.removeArgsForCall = append(fake.removeArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.RemoveStub
	fakeReturns := fake.removeReturns
	fake.recordInvocation("Remove", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.removeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) RemoveCallCount() int {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	return len(fake.removeArgsForCall)
}

func (fake *RelationStoreTxString) RemoveCalls(stub func(context.Context, kv.Tx, string, []string) error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = stub
}

func (fake *RelationStoreTxString) RemoveArgsForCall(i int) (context.Context, kv.Tx, string, []string) {
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	argsForCall := fake.removeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *RelationStoreTxString) RemoveReturns(result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	fake.removeReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) RemoveReturnsOnCall(i int, result1 error) {
	fake.removeMutex.Lock()
	defer fake.removeMutex.Unlock()
	fake.RemoveStub = nil
	if fake.removeReturnsOnCall == nil {
		fake.removeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) Replace(arg1 context.Context, arg2 kv.Tx, arg3 string, arg4 []string) error {
	var arg4Copy []string
	if arg4 != nil {
		arg4Copy = make([]string, len(arg4))
		copy(arg4Copy, arg4)
	}
	fake.replaceMutex.Lock()
	ret, specificReturn := fake.replaceReturnsOnCall[len(fake.replaceArgsForCall)]
	fake.replaceArgsForCall = append(fake.replaceArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 string
		arg4 []string
	}{arg1, arg2, arg3, arg4Copy})
	stub := fake.ReplaceStub
	fakeReturns := fake.replaceReturns
	fake.recordInvocation("Replace", []interface{}{arg1, arg2, arg3, arg4Copy})
	fake.replaceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) ReplaceCallCount() int {
	fake.replaceMutex.RLock()
	defer fake.replaceMutex.RUnlock()
	return len(fake.replaceArgsForCall)
}

func (fake *RelationStoreTxString) ReplaceCalls(stub func(context.Context, kv.Tx, string, []string) error) {
	fake.replaceMutex.Lock()
	defer fake.replaceMutex.Unlock()
	fake.ReplaceStub = stub
}

func (fake *RelationStoreTxString) ReplaceArgsForCall(i int) (context.Context, kv.Tx, string, []string) {
	fake.replaceMutex.RLock()
	defer fake.replaceMutex.RUnlock()
	argsForCall := fake.replaceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *RelationStoreTxString) ReplaceReturns(result1 error) {
	fake.replaceMutex.Lock()
	defer fake.replaceMutex.Unlock()
	fake.ReplaceStub = nil
	fake.replaceReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) ReplaceReturnsOnCall(i int, result1 error) {
	fake.replaceMutex.Lock()
	defer fake.replaceMutex.Unlock()
	fake.ReplaceStub = nil
	if fake.replaceReturnsOnCall == nil {
		fake.replaceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.replaceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) StreamIDs(arg1 context.Context, arg2 kv.Tx, arg3 chan<- string) error {
	fake.streamIDsMutex.Lock()
	ret, specificReturn := fake.streamIDsReturnsOnCall[len(fake.streamIDsArgsForCall)]
	fake.streamIDsArgsForCall = append(fake.streamIDsArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 chan<- string
	}{arg1, arg2, arg3})
	stub := fake.StreamIDsStub
	fakeReturns := fake.streamIDsReturns
	fake.recordInvocation("StreamIDs", []interface{}{arg1, arg2, arg3})
	fake.streamIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) StreamIDsCallCount() int {
	fake.streamIDsMutex.RLock()
	defer fake.streamIDsMutex.RUnlock()
	return len(fake.streamIDsArgsForCall)
}

func (fake *RelationStoreTxString) StreamIDsCalls(stub func(context.Context, kv.Tx, chan<- string) error) {
	fake.streamIDsMutex.Lock()
	defer fake.streamIDsMutex.Unlock()
	fake.StreamIDsStub = stub
}

func (fake *RelationStoreTxString) StreamIDsArgsForCall(i int) (context.Context, kv.Tx, chan<- string) {
	fake.streamIDsMutex.RLock()
	defer fake.streamIDsMutex.RUnlock()
	argsForCall := fake.streamIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) StreamIDsReturns(result1 error) {
	fake.streamIDsMutex.Lock()
	defer fake.streamIDsMutex.Unlock()
	fake.StreamIDsStub = nil
	fake.streamIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) StreamIDsReturnsOnCall(i int, result1 error) {
	fake.streamIDsMutex.Lock()
	defer fake.streamIDsMutex.Unlock()
	fake.StreamIDsStub = nil
	if fake.streamIDsReturnsOnCall == nil {
		fake.streamIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) StreamRelatedIDs(arg1 context.Context, arg2 kv.Tx, arg3 chan<- string) error {
	fake.streamRelatedIDsMutex.Lock()
	ret, specificReturn := fake.streamRelatedIDsReturnsOnCall[len(fake.streamRelatedIDsArgsForCall)]
	fake.streamRelatedIDsArgsForCall = append(fake.streamRelatedIDsArgsForCall, struct {
		arg1 context.Context
		arg2 kv.Tx
		arg3 chan<- string
	}{arg1, arg2, arg3})
	stub := fake.StreamRelatedIDsStub
	fakeReturns := fake.streamRelatedIDsReturns
	fake.recordInvocation("StreamRelatedIDs", []interface{}{arg1, arg2, arg3})
	fake.streamRelatedIDsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *RelationStoreTxString) StreamRelatedIDsCallCount() int {
	fake.streamRelatedIDsMutex.RLock()
	defer fake.streamRelatedIDsMutex.RUnlock()
	return len(fake.streamRelatedIDsArgsForCall)
}

func (fake *RelationStoreTxString) StreamRelatedIDsCalls(stub func(context.Context, kv.Tx, chan<- string) error) {
	fake.streamRelatedIDsMutex.Lock()
	defer fake.streamRelatedIDsMutex.Unlock()
	fake.StreamRelatedIDsStub = stub
}

func (fake *RelationStoreTxString) StreamRelatedIDsArgsForCall(i int) (context.Context, kv.Tx, chan<- string) {
	fake.streamRelatedIDsMutex.RLock()
	defer fake.streamRelatedIDsMutex.RUnlock()
	argsForCall := fake.streamRelatedIDsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *RelationStoreTxString) StreamRelatedIDsReturns(result1 error) {
	fake.streamRelatedIDsMutex.Lock()
	defer fake.streamRelatedIDsMutex.Unlock()
	fake.StreamRelatedIDsStub = nil
	fake.streamRelatedIDsReturns = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) StreamRelatedIDsReturnsOnCall(i int, result1 error) {
	fake.streamRelatedIDsMutex.Lock()
	defer fake.streamRelatedIDsMutex.Unlock()
	fake.StreamRelatedIDsStub = nil
	if fake.streamRelatedIDsReturnsOnCall == nil {
		fake.streamRelatedIDsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.streamRelatedIDsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *RelationStoreTxString) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addMutex.RLock()
	defer fake.addMutex.RUnlock()
	fake.deleteMutex.RLock()
	defer fake.deleteMutex.RUnlock()
	fake.iDsMutex.RLock()
	defer fake.iDsMutex.RUnlock()
	fake.invertMutex.RLock()
	defer fake.invertMutex.RUnlock()
	fake.mapIDRelationsMutex.RLock()
	defer fake.mapIDRelationsMutex.RUnlock()
	fake.mapRelationIDsMutex.RLock()
	defer fake.mapRelationIDsMutex.RUnlock()
	fake.relatedIDsMutex.RLock()
	defer fake.relatedIDsMutex.RUnlock()
	fake.removeMutex.RLock()
	defer fake.removeMutex.RUnlock()
	fake.replaceMutex.RLock()
	defer fake.replaceMutex.RUnlock()
	fake.streamIDsMutex.RLock()
	defer fake.streamIDsMutex.RUnlock()
	fake.streamRelatedIDsMutex.RLock()
	defer fake.streamRelatedIDsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *RelationStoreTxString) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ kv.RelationStoreTxString = new(RelationStoreTxString)
